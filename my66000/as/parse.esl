
package parse
{
    const db: boolean = false;
    alias lex.SkipWS as SkipWS;
    alias lex.Symbol as GetSym;
    alias expr.Expr0 as Expr;
    alias segment.curseg as curseg;

    proc TryReg(s: @[]_byte): @[]_byte, _uint
    {
	if s[0] == 'r' then
	{   if s[1]
	    is '1' then
	    {	if s[2]
	    	is '0'..'9' then
	    	    return s[3:], s[2] - '0' + 10;
	    	else
	    	    return s[2:], 1;
	    }
	    is '2' then
	    {	if s[2]
	    	is '0'..'9' then
	    	    return s[3:], s[2] - '0' + 20;
	    	else
	    	    return s[2:], 2;
	    }
	    is '3' then
	    {	if s[2]
	    	is '0'..'1' then
	    	    return s[3:], s[2] - '0' + 30;
	    	else
	    	    return s[2:], 3;
	    }
	    is '0', '4'..'9' then
	    	return s[2:], s[1] - '0';
	}
	elif s[0] == 's' && s[1] == 'p' then return s[2:], 31;
	elif s[0] == 'i' && s[1] == 'p' then return s[2:], 32;
	return s[0:], 0;
    }

    proc GetReg(s: @[]_byte): @[]_byte, _uint
    {   var reg: _uint;
	var r: @[]_byte;

	r, reg = TryReg(s);
	if r == s then
{
	    Syntax("register expected");
fde.str(r); fde.nl();
}
	return r, reg;
    }

    proc GetBaseReg(s: @[]_byte): @[]_byte, _uint
    {   var reg: _uint;

         s, reg = GetReg(s);
	 if reg == 32 then reg = 0;	// ip as base register
	 return s, reg;
    }

    proc CheckComma(s: @[]_byte): @[]_byte
    {
	s = SkipWS(s);
	if s[0] != ',' then
	    return 0;
	s = SkipWS(s[1:]);
	return s;
    }

    proc SkipComma(s: @[]_byte): @[]_byte
    {   var r: @[]_byte;

	r = CheckComma(s);
	if r == 0 then
	{   Syntax("',' expected");
	    return s;
	}
	return r;
    }

    proc ScanComma(s: @[]_byte, term: _byte): @[]_byte
    {
	loop
	{ exit s[0] == ',';
	  exit s[0] == '\n' || s[0] == term with s = 0;
	    s = s[1:];
	}
	return s;
    }


import my66000def;

    const CondNames4: [Conditions][4]_byte =
    {	'eq0', 'ne0', 'ge0', 'lt0', 'gt0', 'le0', "a",   "n",
	'deq', 'dne', 'dge', 'dlt', 'dgt', 'dle', 'dor', 'dun',
	'feq', 'fne', 'fge', 'flt', 'fgt', 'fle', 'for', 'fun',
	'in',  "",    "",    "",    "",    "",    'rfe', 'ret'
    };

    proc GetCond(s: @[]_byte): @[]_byte, _uint
    {   var r:  @[]_byte;
	var n: _uint;
	var cond: [4]_byte;

	r = s;
	s, n = lex.Symbol(s);
	if s == r then	// not a symbol
	{   Syntax("Expecting branch condition");
	    return r, 0;
	}
	cond[0:n] = r[0:n];
	while n < 4 do
	{   cond[n] = 0;
	    n += 1;
	}
//fde.str("GetCond='"); fde.strn(cond, 4); fde.str("'\n");
	// search for condition name
	n = 0;
	while n <= 31 && cond != CondNames4[n] do
	    n += 1;
	if n > 31 then
	{   Syntax("Unknown branch condition");
	    return r, 0;
	}
	return s, n;
    }

    // All 16-bit immediates are sign extended
    proc IsImm16(x: _int64): boolean
    {
	return x >= _int16?min && x <= _int16?max;
    }

    proc IsImm32(x: _int64, unsigned: boolean): boolean
    {
	if unsigned then
	    return _uint64(x) <= _uint64(_uint32?max);
	else
	    return x >= _int32?min && x <= _int32?max;
    }

/*
    proc IsFloat32(x: @_uint64): boolean
    {
//fde.str("IsFloat32: "); fde.hex64(x@); fde.nl();
	var fxx, f64: _float64;
	var f32: _float32;
	f64 = _float64(x@);
	f32 = f64;
	fxx = f32;
	if fxx == f64 then
	{   x@ = _uint64(_uint32(f32));
	    return true;
	}
	return false;
    }
*/

    proc ZeroOp(s: @[]_byte, opt: _uint32)
    {
	segment.Put4(opt);
    }

    proc Int3Op(s: @[]_byte, opt: _uint32)
    {	var op3: OP3 = OP3(opt);
	var imm: expr.ExprT;

	s, op3.rd = GetReg(s);
	s = SkipComma(s);
	s, op3.rs1 = GetReg(s);
	s = SkipComma(s);
	s, op3.rs2 = GetReg(s);
	s = SkipComma(s);
	if s[0] == '#' then
	{   if op3.minor == 0b010 then	// INS, parse like shift
	    {   var w, o: _uint;
		w = 0;
		s = SkipWS(s[1:]);
		s, o = lex.Dec(s);
		s = SkipComma(s);
		if s[0] == '#' then
		{   s = SkipWS(s[1:]);
		    s, w = lex.Dec(s);
		}
		else
		    Syntax("width field missing");
		imm.offs = (w << 6)| o;
		imm.op = NONE;
	    }
	    else
	    {	s = Expr(s[1:], imm);
		if imm.op != NONE then
		{	Syntax("Illegal immediate value");
		    return;
		}
	    }
	    op3.I = 1;
	}
	else
	{   s, op3.rs3 = GetReg(s);
	}
	if op3.I == 0 then
	{
	    segment.Put4(_uint32(op3));
	}
	else
	{   if IsImm32(imm.offs, false) then
	    {   op3.s1 = 0;
		segment.Put4(_uint32(op3));
		segment.Put4(_uint32(imm.offs));
	    }
	    else
	    {   op3.s1 = 1;
		segment.Put4(_uint32(op3));
		segment.Put8(_uint64(imm.offs));
	    }
	}
    }

    // FIXME - refactor this and Int3Op to have common tail?
    proc FmacOp(s: @[]_byte, opt: _uint32)
    {	var op3: OP3 = OP3(opt);
	var imm: expr.ExprT;

	s, op3.rd = GetReg(s);
	s = SkipComma(s);
	s, op3.rs1 = GetReg(s);
	s = SkipComma(s);
	if s[0] == '#' then
	{   s = Expr(s[1:], imm);
	    if imm.op != NONE then
	    {	Syntax("Illegal immediate value");
		return;
	    }
	    op3.I = 1;
	    op3.s2 = 1;
	}
	else
	{   if s[0] == '-' then
	    {	s = SkipWS(s[1:]);
		op3.s1 = 1;
	    }
	    s, op3.rs2 = GetReg(s);
	}
	s = SkipComma(s);
	if s[0] == '#' then
	{   s = Expr(s[1:], imm);
	    if imm.op != NONE then
	    {	Syntax("Illegal immediate value");
		return;
	    }
	    // FIXME - if op3.I already set then error
	    op3.I = 1;
	    op3.s1 = 1;
	}
	else
	{   if s[0] == '-' then
	    {	s = SkipWS(s[1:]);
		op3.s2 = 1;
	    }
	    s, op3.rs3 = GetReg(s);
	}
	if op3.I == 0 then
	{
	    segment.Put4(_uint32(op3));
	}
	else
	{   if imm.offs <= 0xFFFF_FFFF then	// FIXME
	    {   op3.s1 = 0;
		segment.Put4(_uint32(op3));
		segment.Put4(_uint32(imm.offs));
	    }
	    else
	    {   op3.s1 = 1;
		segment.Put4(_uint32(op3));
		segment.Put8(_uint64(imm.offs));
	    }
	}
    }

    proc Int1Op(s: @[]_byte, opt: _uint32)
    {   var op: OP1b = OP1b(opt);
	var imm: expr.ExprT;

	if s[0] == '-' then
	{   op.sd = 1;
	    s = SkipWS(s[1:]);
	}
	s, op.rd = GetReg(s);
	s = SkipComma(s);
	if s[0] == '#' then
	{   s = Expr(s[1:], imm);
	    op.I = 1;
	    if imm.op == NONE then
	    {	if IsImm32(imm.offs, false) then	// rw
		{   op.D = 0;
		    segment.Put4(_uint32(op));
		    segment.Put4(_uint32(imm.offs));
		}
		else
		{   op.D = 1;
		    segment.Put4(_uint32(op));		// rd
		    segment.Put8(_uint64(imm.offs));
		}
	    }
	    else
	    {	op.D = 1;	// FIXME - only 64-bit fixups?
		segment.Put4(_uint32(op));
		segment.FixNew(imm, ABS_64, EXPR);
		segment.Put8(_uint64(imm.offs));
	    }
	}
	else	// rr
	{   if s[0] == '-' then
	    {   op.s1 = 1;
		s = SkipWS(s[1:]);
	    }
	    s, op.rs1 = GetReg(s);
	    segment.Put4(_uint32(op));
	}
   }

    proc MovOp(s: @[]_byte, opt: _uint32)
    {   var rd, rs: _uint;
	var opim: OPIMM = OPIMM(opt);
	var op: OP1b;
	var imm: expr.ExprT;
	var r: @[]_byte;

	r = s;	// save for re-parse
	op = {.major=0b001101, .minor=0b000101,.I=0,.s=1,.func=0 };
	if s[0] == '-' then
	{   op.sd = 1;
	    s = SkipWS(s[1:]);
	}
	s, rd = GetReg(s);
	s = SkipComma(s);
	if s[0] == '#' then
	{   s = Expr(s[1:], imm);
	    if imm.op == NONE && IsImm16(imm.offs) then	// MOVri
	    {   opim.rd = rd;
		opim.imm = _uint16(imm.offs);
		segment.Put4(_uint32(opim));
		return;
	    }
	}
	// Re-parse as a 1-op
	Int1Op(r, _uint32(op));
    }

    proc Int1rOp(s: @[]_byte, opt: _uint32)
    {	var op2: OP2 = OP2(opt);
	op2.major = 0b001010;	// assume not imm16
	s, op2.rd = GetReg(s);
	s = SkipComma(s);
	if s[0] == '-' then
	{   op2.s1 ^= 1;
	    s = SkipWS(s[1:]);
	}
	s, op2.rs1 = GetReg(s);
	// rs2 set to same as rs1
	op2.rs2 = op2.rs1;
	segment.Put4(_uint32(op2));
    }

    proc IntOp(s: @[]_byte, opt: _uint32)
    {	var op2: OP2 = OP2(opt);
	var opim: OPIMM;
	var imm: expr.ExprT;
	type FuncType: (INT, LOG, SHF, FLT, CVT);
	var func: FuncType;
	var immop: 0..2;	// where is immediate operand
	var r: @[]_byte;
	const FuncTable: [32]FuncType =
	{ INT, INT, INT, INT, INT, INT, INT, INT,
	  LOG, LOG, LOG, LOG, SHF, SHF, SHF, SHF,
	  FLT, FLT, FLT, FLT, FLT, FLT, FLT, FLT,
	  FLT, FLT, FLT, FLT, FLT, FLT, FLT, FLT
	};

	if op2.minor < 0b100000 then func = CVT;
	else func = FuncTable[op2.minor & 0x1F];
	op2.major = 0b001010;	// assume not imm16
	immop = 0;
	// op.s2 may be already set to 1 for subtracts
	// op.s1 could be in the future for logics
	s, op2.rd = GetReg(s);
	s = SkipComma(s);
	// second arg can be '#imm' or '-reg' or 'reg'
	if s[0] == '#' then
	{   s = Expr(s[1:], imm);
	    immop = 1;
	}
	else
	{   if s[0] == '-' then
	    {   op2.s1 ^= 1;
		s = SkipWS(s[1:]);
	    }
	    s, op2.rs1 = GetReg(s);
	}
	r = CheckComma(s);
	if r == 0 then
	{   if func == CVT then
	    {   // missing arg for CVT/RND use current mode
		// unless src1 was immediate, then use R0
		if immop != 0 then
		{   op2.rs2 = 0;	// reg R0
		}
		else
		{   const RM: expr.ExprT = {NONE, RoundingModes.CM, 0, 0 };
		    imm = RM;
		    immop = 2;
		}
	    }
	    else Syntax("',' expected");
	}
	else
	{   s = r;
	    // third arg can be '#imm' (if 2nd was not) or '-reg' or 'reg'
	    // if third arg is 16-bit immediate then different format
	    // save forced inversion, e.g. sub
	    if s[0] == '#' then
	    {   if immop != 0 then
		{   fde.str("More than one immediate is illegal\n");
		}
		s = Expr(s[1:], imm);
		immop = 2;
	    }
	    else
	    {   if s[0] == '-' then
		{   op2.s2 ^= 1;
		    s = SkipWS(s[1:]);
		}
		s, op2.rs2 = GetReg(s);
	    }
	}
	if immop == 0 then	// both operands are registers
	{   segment.Put4(_uint32(op2));
	    return;
	}
	else	// we have an immediate
	{   if imm.op != NONE then
	    {	fde.str("arg non-constant immediate expr=");
		expr.Dump(fde, imm); fde.nl();
	    }
	    var immval:_uint64  = imm.offs;
	    var reginv, imminv: boolean;
	    if immop == 1 then
	    {	reginv = op2.s2 != 0;
		imminv = op2.s1 != 0;
	    }
	    else
	    {	reginv = op2.s1 != 0;
		imminv = op2.s2 != 0;
	    }
	    if imminv then	// if forced inversion of immediate
	    {   if func
		is LOG then immval = ~immval;
		is INT then immval = -immval;
		// FIXME - FLT, CVT, SHF?
	    }
	    var altop: _uint = opt >> 26;	// get alternate opcode
	    // Check for 16-bit immediate version and prefer it
	    if altop != 0 &&	// has IMM16 version
	       immop == 2 &&	// operand 2 is immediate
	       op2.s1 == 0 &&	// operand 1 is not inverted register
	       IsImm16(immval) then
	    {   opim = OPIMM(_uint32(op2));
		opim.major = altop;	// use alternate opcode
		opim.imm = _uint16(immval);
		segment.Put4(_uint32(opim));
		return;
	    }
	    // check for IMM5
	    if _abs(immval) <= 31 &&		// value fits
	       !reginv then			// and no reg inversion
	    {	if immop == 1 then
		{   op2.rs1 = _abs(immval);
		    op2.s2 = 1;
		}
		else
		{   op2.rs2 = _abs(immval);
		    op2.s2 = 0;
		}
		op2.s1 = immval < 0;
		op2.D = 1;
		segment.Put4(_uint32(op2));
		return;
	    }
	    op2.I = 1;
	    // Now check size of immediate
	    if func == FLT then
	    {   if imm.offs <= 0xFFFF_FFFF then	// FIXME
		    op2.D = 0;
		else
		    op2.D = 1;
	    }
	    else
	    {   if IsImm32(immval, false) then
		    op2.D = 0;
		else
		    op2.D = 1;
	    }
	    if immop == 1 then
	    {	op2.s1 = op2.s2;
		op2.s2 = 1;
	    }
	    else
		op2.s2 = 0;
	    segment.Put4(_uint32(op2));
	    if op2.D == 0 then
		segment.Put4(_uint32(immval));
	    else
		segment.Put8(_uint64(immval));
	}
    }

    proc ShfOp(s: @[]_byte, opt: _uint32)
    {
	var rd, rs1, rs2: _uint;
	var w, o: _uint;
	var dynamic: boolean;

	w = 0;
	s, rd = GetReg(s);
	s = SkipComma(s);
	s = SkipWS(s);
	s, rs1 = GetReg(s);
	s = SkipComma(s);
	if s[0] == '#' then	// o is immediate
	{   s = SkipWS(s[1:]);
	    s, o = lex.Dec(s);
	    dynamic = false;
	}
	else			// o in register
	{   s, rs2 = GetReg(s);
	    dynamic = true;
	}
	s = CheckComma(s);
	if s != 0 then		// w is present
	{   if s[0] == '#' then
	    {   s = SkipWS(s[1:]);
		s, w = lex.Dec(s);
	    }
	    else
		Syntax("width field missing");
	}
	if dynamic then
	{   var opr: OPSHFR = OPSHFR(opt);
	    opr.major = 0b001000;
	    opr.rd = rd;
	    opr.rs1 = rs1;
	    opr.w = w;
	    opr.z = 0;
	    opr.rs2 = rs2;
	    segment.Put4(_uint32(opr));
	}
	else
	{   var ops: OPSHF = OPSHF(opt);
	    ops.rd = rd;
	    ops.rs1 = rs1;
	    ops.w = w;
	    ops.o = o;
	    segment.Put4(_uint32(ops));
	}
    }

    proc Pred(s: @[]_byte, opt: _uint32)
    {	var op: OPPB = OPPB(opt);	// or OPPC
	var t, e, i, n: _uint;

	s,op.rs1 = GetReg(s);
	s = SkipComma(s);
	s = SkipWS(s);
	t = 0;  e = 0;
	i = 0;
	while i < 16 &&
	      s[i] == 'T' || s[i] == 't' ||
	      s[i] == 'F' || s[i] == 'f' do
	{   if s[i] == 'F' || s[i] == 'f' then
		e += 1;
	    else
		t += 1;
	    i += 1;
	}
//fde.str("shadow='"); fde.strn(s, i); fde.str("' i="); fde.uint(i);
//fde.str(" m="); fde.hex8(_uint8(m)); fde.nl();
	op.else = e;
	op.then = t;
	segment.Put4(_uint32(op));
    }

    proc PcOp(s: @[]_byte, opt: _uint32)
    {	var op: OPPC = OPPC(opt);
	var r: @[]_byte;
	var n, m: _uint;

	r, n = GetCond(s);
	op.cond = n;
	s = SkipComma(s);
	Pred(s, _uint32(op));
    }

    proc PbOp(s: @[]_byte, opt: _uint32)
    {	var op: OPPB = OPPB(opt);
	var r: @[]_byte;
	var n, m: _uint;

	r = s;
	s, n = lex.Dec(s);
	if s == r then	// not literal bit number
	{
	}
	op.bit = n;
	s = SkipComma(s);
	Pred(s, _uint32(op));
    }

    proc VecOp(s: @[]_byte, opt: _uint32)
    {   var op: OPVEC = OPVEC(opt);
	var r: @[]_byte;
	var rd, reg: _uint;
	var mask: _uint32;
//		       33222222222211111111110000000000
//		       10987654321098765432109876543210
	const vecs = 0b01111110000000001111111111111110;

	s,rd = GetReg(s);
	s = SkipComma(s);
	mask = 0;
	if s[0] == '{' then
	{   s = SkipWS(s[1:]);
	    loop
	    {
	      exit s[0] == '}';
	        s,reg = GetReg(s);
		mask |= 1 << reg;
		r = CheckComma(s);
	      exit r == 0;
		s = r;
	    }
	}
	else
	    Syntax("'{' expected\n");
	if mask & ~vecs == 0 then	// use short VEC
	{   op.rd = rd;
	    op.imm = ((mask >> 1)  & 0x007FFF) |
	             ((mask >> 10) & 0x3F8000);
	    segment.Put4(_uint32(op));
	}
	else				// use long VEC
	{   var op1: OP1b = OP1b(0b001101_00000_00000_10100_011101_00000);
	    op1.rd = rd;
	    segment.Put4(_uint32(op1));
	    segment.Put4(mask);
	}
    }

    proc GetLoopCompare(s: @[]_byte): @[]_byte, _uint, boolean
    {   var i: _uint;
	var signed: boolean = false;
	const CNDNames: [10][2]_byte =
	{   'eq',  'ne', 'hs',  'lo',  'hi',  'ls',	// unsigned
	    'ge',  'lt',  'gt', 'le'			// signed
	};

	if s[0] == 'a' then return s[1:0], 6, false;
	i = 0;
	while i < 10 && s[0:2] != CNDNames[i][0:2] do
	    i += 1;
	if i > 10 then
	{   Syntax("Illegal loop condition\n");
	    return s, 0, false;
	}
	if i > 6 then
	{   i -= 4;
	    signed = true;
	}
	return s[2:0], i, signed;
    }

    proc LoopOp(s: @[]_byte, opt: _uint32)
    {   var op: OPLOOP = OPLOOP(opt);
	var signed: boolean;
	var kind: _uint;
	var r: @[]_byte;
	var immop: (NONE, RS2, RS3, BOTH);
	var immsz: (IMM5, IMM32, IMM64);
	var imm2, imm3: expr.ExprT;

	kind = op.kind;
	immop = NONE;
	// rd is cnd
	// rs1 is rloop
	// rs2 is rcmp or imm
	// rs3 is rinc or imm
	s, op.cnd, signed = GetLoopCompare(s);
	if signed then op.s = 1;
	s = SkipComma(s);		// 1st comma
	s, op.rs1 = GetReg(s);		// loop register
	s = SkipComma(s);		// 2nd comma
	// rs2 can be '#imm' or 'reg'
	if s[0] == '#' then
	{   s = Expr(s[1:], imm2);
	    if imm2.op != NONE then
	    {	fde.str("arg non-constant immediate expr=");
		expr.Dump(fde, imm2); fde.nl();
	    }
	    immop = RS2;
	}
	else
	    s, op.rs2 = GetReg(s);
	s = SkipComma(s);
	// rs3 can be '#imm' or 'reg'
	if s[0] == '#' then
	{   s = Expr(s[1:], imm3);
	    if imm3.op != NONE then
	    {	fde.str("arg non-constant immediate expr=");
		expr.Dump(fde, imm3); fde.nl();
	    }
	    if immop != NONE then
		immop = BOTH;
	    else
		immop = RS3;
	}
	else
	    s, op.rs3 = GetReg(s);
	if immop
	is RS2 then
	{
	    if imm2.offs >= 0 && imm2.offs <= 31 then
	    {	op.s2 = 1;
		op.rs2 = imm2.offs;
	    }
	    else
	    {	op.I = 1;
		if IsImm32(imm2.offs, false) then
		    op.s1 = 0;
		else
		    op.s1 = 1;
	    }
	}
	is RS3 then
	{
	    if imm3.offs >= 0 && imm3.offs <= 31 then
	    {	op.s1 = 1;
		op.rs3 = imm3.offs;
	    }
	    elif IsImm32(imm3.offs, false) then
	    {	op.I = 1;
		op.s2 = 1;
	    }
	    else
		fde.str("Immediate value too large for RS3\n");
	}
	is BOTH then	// two immediates
	{
	    if (imm2.offs >= 0 && imm2.offs <= 31) &&
	       (imm3.offs >= 0 && imm3.offs <= 31) then
	    {	op.s2 = 1;
		op.rs2 = imm2.offs;
		op.s1 = 1;
		op.rs3 = imm3.offs;
	    }
	    else
	    {   op.I = 1;
		op.s1 = 1;
		if IsImm32(imm2.offs, false) && IsImm32(imm3.offs, false) then
		    ;
		elif imm3.offs == 1 then
		    op.s2 = 1;
		else
		    fde.str("Illegal LOOP immediates\n");
	    }
	}

if debug.vec then {
fde.str("kind="); fde.uint(kind);
fde.str(" comp="); fde.uint(op.cnd);
fde.str(" signed="); fde.uint8(_uint8(signed));
fde.str(" iss="); fde.uint(op.I); fde.uint(op.s1); fde.uint(op.s2);
if immop == RS2 || immop == BOTH then
{  fde.str(" imm2="); fde.int(imm2.offs); }
if immop == RS3 || immop == BOTH then
{  fde.str(" imm3="); fde.int(imm3.offs); }
fde.nl();
}
	segment.Put4(_uint32(op));
	if op.I != 0 then
	{   if op.s1 == 0 then
	    {   if op.s2 == 0 then
		    segment.Put4(_uint32(imm2.offs));
		else
		    segment.Put4(_uint32(imm3.offs));
	    }
	    else
	    {	if op.s2 == 0 then
		{
		    segment.Put4(_uint32(imm2.offs));
		    segment.Put4(_uint32(imm3.offs));
		}
		else
		    segment.Put8(_uint64(imm2.offs));
	    }
	}
    }

    proc CarryOp(s: @[]_byte, opt: _uint32)
    {	var op: OPCARRY = OPCARRY(opt);
	var mask: _uint16;
	var shf: _uint;

	s,op.rd = GetReg(s);
	s = SkipComma(s);
	if s[0] != '{' then
	{   Syntax("Expecting '{'\n");
	    return;
	}
	s = SkipWS(s[1:]);
	mask = 0;
	shf = 0;
	loop
	{   s = SkipWS(s);
	    if s[0]
	    is 'I' then
	    {   mask |= 1 << shf;
		s = s[1:];
		if s[0] == 'O' then
		{   mask |= 2 << shf;
		    s = s[1:];
		}
	    }
	    is 'O' then
	    {   mask |= 2 << shf;
		s = s[1:];
		if s[0] == 'I' then
		{   mask |= 1 << shf;
		    s = s[1:];
		}
	    }
	    is '-' then ;
	    else Syntax("Bad carry IO field\n");
	    s = SkipWS(s);
	    shf += 2;
	  exit shf >= 8 || s[0] != ',';
	    s = SkipComma(s);
	}
	op.imm = mask;
	segment.Put4(_uint32(op));
    }

    proc BbmOp(s: @[]_byte, opt: _uint32)
    {	var op: OPBB = OPBB(opt);
	var tgt: expr.ExprT;

	s,op.rs1 = GetReg(s);
	s = SkipComma(s);
	s = Expr(s, tgt);
	segment.FixNew(tgt, PCREL16_S2, EXPR);
	segment.Put4(_uint32(op));
	segment.Finish(BRC);
    }

    proc BbOp(s: @[]_byte, opt: _uint32)
    {	var op: OPBB = OPBB(opt);
	var r: @[]_byte;
	var tgt: expr.ExprT;
	var n: _uint;

	r = s;
	s, n = lex.Dec(s);
	if s == r then	// not literal bit number
	{
	}
	op.bit = n;
	s = SkipComma(s);
	BbmOp(s, _uint32(op));
    }

    proc SvcOp(s: @[]_byte, opt: _uint32)
    {	var op: OPBC = OPBC(opt);
	var n: _uint;

	if s[0] == '#' then
	{   s, n = lex.Dec(s[1:]);
	    op.rs1 = n;
	    if Conditions(op.cond) == SVC then
	    {	s = SkipComma(s);
		if s[0] == '#' then
		{	s, n = lex.Dec(s[1:]);
		    op.imm = n;
		}
		else Syntax("# expected");
	    }
	    segment.Put4(_uint32(op));
	}
	else Syntax("# expected");
    }

    proc BcmOp(s: @[]_byte, opt: _uint32)
    {	var op: OPBC = OPBC(opt);
	var tgt: expr.ExprT;

	if Conditions(op.cond)
	is RET then
	{   segment.Put4(_uint32(op));
	    segment.Finish(UNC);
	}
	else
	{   s,op.rs1 = GetReg(s);
	    s = SkipComma(s);
	    s = Expr(s, tgt);
	    segment.FixNew(tgt, PCREL16_S2, EXPR);
	    segment.Put4(_uint32(op));
	    segment.Finish(BRC);
	}
    }

    proc BcOp(s: @[]_byte, opt: _uint32)
    {	var op: OPBC = OPBC(opt);
	var r: @[]_byte;
	var n: _uint;

	r, n = GetCond(s);
	op.cond = n;
	s = SkipComma(r);
	BcmOp(s, _uint32(op));
    }

    proc JtOp(s: @[]_byte, opt: _uint32)
    {	var op: OPTT = OPTT(opt);
	var imm: expr.ExprT;

	s,op.rs1 = GetReg(s);
	s = SkipComma(s);
	if s[0] == '#' then
	{   s = Expr(s[1:], imm);
	    if imm.op != NONE then
		Syntax("jtt requires constant immediate");
	    op.imm = imm.offs;
	}
	else
	    Syntax("'#' expected");
	segment.FixNew(0, JTT, SEGM);
	segment.Put4(_uint32(op));
    }

    proc BrOp(s: @[]_byte, opt: _uint32)
    {   var op: OPBR = OPBR(opt);
	var tgt: expr.ExprT;

	s = Expr(s, tgt);
	segment.FixNew(tgt, PCREL26_S2, EXPR);
	segment.Put4(_uint32(op));
	if op.major & 1 != 0 then
	    segment.Finish(CALL);
	else
	    segment.Finish(UNC);
    }

    // HR instruction, do not use for IP
    proc HrOp(s: @[]_byte, opt: _uint32)
    {   var op: OP1a = OP1a(opt);
	var f: _uint;

	if op.r != 0 then
	{   s, op.rd = GetReg(s);
	    s = SkipComma(s);
	}
	if op.w != 0 then
	{   s, op.rs1 = GetReg(s);
	    s = SkipComma(s);
	}
	if s[0]
	is 'M' then f = 0b00001;
	is 'A' then f = 0b00010;
	is 'E' then f = 0b00011;
	is 'S' then f = 0b00100;
	is 'F' then f = 0b00101;
	is 'R' then f = 0b00110;
	is 'W' then f = 0b00111;
	else
	    Syntax("Illegal function for HR instruction");
	op.func = f;
	segment.Put4(_uint32(op));
    }

    // HR for use with IP
    proc BiOp(s: @[]_byte, opt: _uint32)
    {   var op: OP1a = OP1a(opt);

	s, op.rs1 = GetReg(s);
	segment.Put4(_uint32(op));
	if op.r != 0 then	// hr r0=ip=rs1
	    segment.Finish(CALL);
	else			// hr ip=rs1
	    segment.Finish(UNC);
    }

    proc RetOp(s: @[]_byte, opt: _uint32)
    {
	// hr ip=r0
	ZeroOp(s, opt);
	segment.Finish(UNC);
    }

    proc Xop5(s: @[]_byte, opt: _uint32)
    {	var op: OP1b = OP1b(opt);
	var imm: expr.ExprT;
	var kind: (RR, R5, RI) = RR;	// assume r,r
	var func: _uint;
	const inflt: [64]0..1: packed =
	{ 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,
	  0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
	  1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,
	  0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0
	};

	func = op.func;
	if op.major == 0b010001 then	// 2nd encoding of cvt
	    op.func += 0b100000;
//fde.str("func="); fde.hex8(func);
//fde.str(" inflt="); fde.uint(inflt[func]); fde.nl();
	// FIXME - can we have a '-' here?
	s, op.rd = GetReg(s);
	s = SkipComma(s);
	// second arg can be '#imm' or '-reg' or 'reg'
	if s[0] == '#' then
	{   s = Expr(s[1:], imm);
	    kind = RI;
	}
	else
	{   if s[0] == '-' then
	    {   op.s1 ^= 1;
		s = SkipWS(s[1:]);
	    }
	    s, op.rs1 = GetReg(s);
	}
	// FIXME - optional 3rd argument rounding mode
	if kind <= R5 then
	{   segment.Put4(_uint32(op));
	    return;
	}
	else	// we have an immediate
	{   if imm.op == NONE then
	    {   if imm.offs >= -16 && imm.offs <= 15 then
		{   op.rs1 = _uint(imm.offs) & 0x1F;
		    op.D = 1;
		    segment.Put4(_uint32(op));
		    return;
		}
		op.I = 1;
		if inflt[func] != 0 then
		{   if imm.offs <= 0xFFFF_FFFF then	// FIXME
			op.D = 0;
		    else
			op.D = 1;
		}
		else
		{   if IsImm32(imm.offs, false) then
			op.D = 0;
		    else
			op.D = 1;
		}
	    }
	    else
	    {	fde.str("arg non-constant immediate kind=");
		fde.uint8(_uint8(kind));
		fde.str(" expr="); expr.Dump(fde, imm); fde.nl();
	    }
	    segment.Put4(_uint32(op));
	    if op.D == 0 then
		segment.Put4(_uint32(imm.offs));
	    else
		segment.Put8(_uint64(imm.offs));
	}
    }

    proc MemOp(s: @[]_byte, opt: _uint32)
    {	var op: OPMEM = OPMEM(opt);
	var rb: _uint;
	var imm, dat: expr.ExprT;
	var r: @[]_byte;
	var datasize: _uint = 0;
	var needreloc: boolean = false;

	op.major = 0b001001;
	s = SkipWS(s);
	if s[0] == '#' then	// for store immediate
	{
	    if op.minor & 0b111100 != 0b001000 then
	    {	Syntax("Immediate data not allowed");
		return;
	    }
	    op.minor |= 0b010000;	// make store immediate
	    s = SkipWS(s[1:]);
	    s = Expr(s, dat);
	    if dat.op == NONE then
	    {   if dat.offs >= -16 && dat.offs <= 15 then
		{   op.rd = dat.offs & 0x1F;
		    op.minor |= 0b100;	// make short version
		    datasize = 1;
		}
		else	// long version
		{   datasize = 2;
		    if op.minor == 0b011011 then	// STD
			datasize = 3;
		}
	    }
	    else
		fde.str("Non-constant data not yet handled\n");
	    s = SkipComma(s);
	}
	elif op.minor <= 0b100000 then	//not CALX or CALA
	{   s, op.rd = GetReg(s);
	    s = SkipComma(s);
	}
	if s[0] == '[' then
	{   s = SkipWS(s[1:]);
	    // we require base register to be specified
	    s, op.rb = GetBaseReg(s);
	    if s[0] != ']' then	// not just [rb]
	    {	s = SkipComma(s);
		r = ScanComma(s, ']');	// is there another comma?
		if r != 0 then		// yes, has index register
		{   s, op.ri = GetReg(s);
		    s = SkipWS(s);
		    if s[0:2] == '<<' then
		    {   s = SkipWS(s[2:]);
			s,op.sc = lex.Dec(s);	// FIXME - op.sc in 0..3
		    }
		    s = SkipComma(s);
		}
		s = SkipWS(s);
		// we require an offset, even if it is zero
		s = Expr(s, imm);
	    }
	    else
	    {	imm.offs = 0;
		imm.op = NONE;
	    }
	    // now check if we can use a short version
	    if datasize == 0 && op.ri == 0 && imm.op == NONE &&
		    op.L == 0 &&
		    IsImm16(imm.offs) && (opt >> 26) != 0 then
	    {   var opmi: OPMEMIMM = OPMEMIMM(_uint32(op));
		opmi.major = opt >> 26;	// use alternate opcode
		opmi.imm = _uint16(imm.offs);
		segment.Put4(_uint32(opmi));
		return;
	    }
	    if imm.op == NONE then
	    {	if imm.offs != 0 then
		{   op.I = 1;
		    if IsImm32(imm.offs, false) then
			op.D = 0;
		    else
			op.D = 1;
		}
	    }
	    else
	    {   op.I = 1;	// FIXME - only 32-bit offset for now
		needreloc = true;
	    }
	    segment.Put4(_uint32(op));
	    if op.I != 0 then
	    {	if op.D == 0 then
		{   if needreloc then
			segment.FixNew(imm, PCREL32, EXPR);
		    segment.Put4(_uint32(imm.offs));
		}
		else
		{   if needreloc then
			segment.FixNew(imm, PCREL64, EXPR);
		    segment.Put8(_uint64(imm.offs));
		}
	    }
	    if datasize
	    is 2 then
	    {	if needreloc then
		    imm.offs += 4;
		segment.Put4(_uint32(dat.offs));
	    }
	    is 3 then
	    {	if needreloc then
		    imm.offs += 8;
		segment.Put8(_uint64(dat.offs));
	    }
	}
	else
	    Syntax("[ expected");
    }

    proc LdmOp(s: @[]_byte, opt: _uint32)
    {	var op: OPMEM = OPMEM(opt);
	var imm: expr.ExprT;
	var needreloc: boolean = false;

	s, op.rd = GetReg(s);	// Rstart
	s = SkipComma(s);
	s, op.ri = GetReg(s);	// Rstop
	s = SkipComma(s);
	if s[0] == '[' then
	{   s = SkipWS(s[1:]);
	    s, op.rb = GetBaseReg(s);
	    if s[0] != ']' then	// not just [rb]
	    {	s = SkipComma(s);
		s = Expr(s, imm);
	    }
	    else
	    {	imm.offs = 0;
		imm.op = NONE;
	    }
	    if imm.op == NONE then
	    {	if imm.offs != 0 then
		{   op.I = 1;
		    if IsImm32(imm.offs, false) then
			op.D = 0;
		    else
			op.D = 1;
		}
	    }
	    else
	    {   op.I = 1;	// FIXME - only 32-bit offset for now
		needreloc = true;
	    }
	    segment.Put4(_uint32(op));
	    if op.I != 0 then
	    {	if op.D == 0 then
		{   if needreloc then
			segment.FixNew(imm, PCREL32, EXPR);
		    segment.Put4(_uint32(imm.offs));
		}
		else
		{   if needreloc then
			segment.FixNew(imm, PCREL64, EXPR);
		    segment.Put8(_uint64(imm.offs));
		}
	    }
	}
	else
	    Syntax("[ expected");
     }

    proc EnterOp(s: @[]_byte, opt: _uint32)
    {	var op: OPMEMIMM = OPMEMIMM(opt);	// close enough model
	var FS: _uint;
	var imm: expr.ExprT;
	var r: @[]_byte;

	s, op.rd = GetReg(s);	// Rstart
	s = SkipComma(s);
	s, op.rb = GetReg(s);	// Rstop
	s = SkipComma(s);
	s = Expr(s, imm);
	if imm.op != NONE then
	    Syntax("Displacement must be constant");
	if (imm.offs & 7) != 0 then
	    Syntax("Displacement must be multiple of 8");
	r = CheckComma(s);
	FS = 0;		// optional FS field
	if r != 0 then
	{   s = r;
	    if s[0] >= '0' && s[0] <= '7' then
		FS = s[0] - '0';
	    else
		Syntax("FS bits must be 0..7");
	}
	op.imm = (imm.offs & 0xFFF8) | FS;
	segment.Put4(_uint32(op));
    }

    proc MmOp(s: @[]_byte, opt: _uint32)
    {	var op: OPMEM = OPMEM(opt);
	var imm: expr.ExprT;
	var val: expr.ExprT;
	var isMS: boolean;
	var hasbyte: boolean;

	isMS = op.minor == 0b110111;
	hasbyte = false;
	s, op.ri = GetReg(s);	// Rto
	s = SkipComma(s);
	if s[0] == '#' then	// possible MS with immediate value
	{   if !isMS then
		Syntax("immediate value not allowed");
	    s = Expr(s[1:], val);
	    if val.op == NONE then
	    {	if val.offs <= 0x0F || val.offs >= 0xF0 then
		{   op.rd = val.offs & 0x1F;
		    op.minor = 0b111100;
		}
		else
		{   hasbyte = true;
		    op.minor = 0b111000;
		}

	    }
	    else
		Syntax("MS value must be constant");
	}
	else
	    s, op.rd = GetReg(s);	// Rfm
	s = SkipComma(s);
	if s[0] == '#' then	// count is immediate
	{   op.I = 1;
	    s = Expr(s[1:], imm);
	    if imm.op == NONE then
	    {	if IsImm32(imm.offs, false) then	// rw
		    op.D = 0;
		else
		    op.D = 1;
	    }
	    else
		Syntax("count must be constant");
	}
	else			// count is register
	    s, op.rb = GetReg(s);	// Rcnt
	segment.Put4(_uint32(op));
	if hasbyte then
	    segment.Put4(_uint32(val.offs & 0xFF));
	if op.I != 0 then
	{   if op.D == 0 then
		segment.Put4(_uint32(imm.offs));
	    else
		segment.Put8(_uint64(imm.offs));
	}
    }


    type InstT:
    {   name:   @[]_byte;
	len:    _uint8;
	opt:    _uint32;
	parse:  @_(s: @[]_byte, opt: _uint32);
    };


    const Insts: []InstT =
    {
    	{ "mov",   3,  0b111011_00000_00000_0000000000000000, MovOp },

	{ "add",   3,  0b110001_00000_00000_00000_100001_00000, IntOp },
	{ "adds",  4,  0b000000_00000_00000_00010_100001_00000, IntOp },
	{ "sub",   3,  0b110001_00000_00000_00100_100001_00000, IntOp },
	{ "subs",  4,  0b000000_00000_00000_00110_100001_00000, IntOp },
	{ "mul",   3,  0b110010_00000_00000_00000_100010_00000, IntOp },
	{ "muls",  4,  0b000000_00000_00000_00010_100010_00000, IntOp },
	{ "div",   3,  0b110011_00000_00000_00000_100011_00000, IntOp },
	{ "divs",  4,  0b000000_00000_00000_00010_100011_00000, IntOp },
	{ "cmp",   3,  0b110100_00000_00000_00000_100100_00000, IntOp },
	{ "max",   3,  0b000000_00000_00000_00000_100110_00000, IntOp },
	{ "maxs",  4,  0b000000_00000_00000_00010_100110_00000, IntOp },
	{ "min",   3,  0b000000_00000_00000_00000_100111_00000, IntOp },
	{ "mins",  4,  0b000000_00000_00000_00010_100111_00000, IntOp },
	{ "or",    2,  0b111000_00000_00000_00000_101000_00000, IntOp },
	{ "xor",   3,  0b111001_00000_00000_00000_101001_00000, IntOp },
	{ "and",   3,  0b111010_00000_00000_00000_101010_00000, IntOp },
	// the next 2 must be parsed with one less register
//	{ "abs",   3,  0b000000_00000_00000_00110_100110_00000, Int1rOp },
	{ "nabs",  4,  0b000000_00000_00000_00110_100111_00000, Int1rOp },

	// normal loads/stores
	{ "ldub",  4,  0b100000_00000_00000_00000_000000_00000, MemOp },
	{ "lduh",  4,  0b100001_00000_00000_00000_000001_00000, MemOp },
	{ "lduw",  4,  0b100010_00000_00000_00000_000010_00000, MemOp },
	{ "ldd",   3,  0b100011_00000_00000_00000_000011_00000, MemOp },
	{ "ldsb",  4,  0b100100_00000_00000_00000_000100_00000, MemOp },
	{ "ldsh",  4,  0b100101_00000_00000_00000_000101_00000, MemOp },
	{ "ldsw",  4,  0b100110_00000_00000_00000_000110_00000, MemOp },
	{ "la",    2,  0b000000_00000_00000_00000_000111_00000, MemOp },
	{ "stb",   3,  0b101000_00000_00000_00000_001000_00000, MemOp },
	{ "sth",   3,  0b101001_00000_00000_00000_001001_00000, MemOp },
	{ "stw",   3,  0b101010_00000_00000_00000_001010_00000, MemOp },
	{ "std",   3,  0b101011_00000_00000_00000_001011_00000, MemOp },

	{ "srl",   3,  0b000111_00000_00000_10000_101100_00000, ShfOp },
	{ "sra",   3,  0b000111_00000_00000_10010_101100_00000, ShfOp },
	{ "sll",   3,  0b000111_00000_00000_10100_101101_00000, ShfOp },
	{ "sla",   3,  0b000111_00000_00000_10110_101101_00000, ShfOp },
	{ "rol",   3,  0b000111_00000_00000_01100_101011_00000, ShfOp },
	{ "ror",   3,  0b000111_00000_00000_01110_101011_00000, ShfOp },
	{ "bitr",  4,  0b000111_00000_00000_11000_101110_00000, ShfOp },

	{ "bb1",   3,  0b01100_000000_00000_0000000000000000, BbOp },
	{ "bcnd",  4,  0b011010_00000_00000_0000000000000000, BcOp },
	{ "br",    2,  0b011110_00000000000000000000000000, BrOp },
	{ "call",  4,  0b011111_00000000000000000000000000, BrOp },

	// bb1 "macros"
	{ "beq",   3,  0b01100_000000_00000_0000000000000000, BbmOp },
	{ "bne",   3,  0b01100_000010_00000_0000000000000000, BbmOp },
	{ "bge",   3,  0b01100_000100_00000_0000000000000000, BbmOp },
	{ "blt",   3,  0b01100_000110_00000_0000000000000000, BbmOp },
	{ "bgt",   3,  0b01100_001000_00000_0000000000000000, BbmOp },
	{ "ble",   3,  0b01100_001010_00000_0000000000000000, BbmOp },
	{ "bhs",   3,  0b01100_001100_00000_0000000000000000, BbmOp },
	{ "blo",   3,  0b01100_001101_00000_0000000000000000, BbmOp },
	{ "bhi",   3,  0b01100_001110_00000_0000000000000000, BbmOp },
	{ "bls",   3,  0b01100_001111_00000_0000000000000000, BbmOp },
	{ "bsin",  4,  0b01100_011000_00000_0000000000000000, BbmOp },
	{ "bfin",  4,  0b01100_011001_00000_0000000000000000, BbmOp },
	{ "bcin",  4,  0b01100_011010_00000_0000000000000000, BbmOp },
	{ "brin",  4,  0b01100_011011_00000_0000000000000000, BbmOp },
	// bcnd "macros"
	{ "beq0",  4,  0b011010_00000_00000_0000000000000000, BcmOp },
	{ "bne0",  4,  0b011010_00001_00000_0000000000000000, BcmOp },
	{ "bge0",  4,  0b011010_00010_00000_0000000000000000, BcmOp },
	{ "blt0",  4,  0b011010_00011_00000_0000000000000000, BcmOp },
	{ "bgt0",  4,  0b011010_00100_00000_0000000000000000, BcmOp },
	{ "ble0",  4,  0b011010_00101_00000_0000000000000000, BcmOp },
	// ret is now a branch on condition with no target
	{ "ret",   3,  0b011010_11111_00000_0000000000000000, BcmOp },
	// ret was a BiOp with implied R0
//	{ "ret",   3,  0b001101_00000_00000_01000_000000_00000, RetOp },

	{ "pb1",   3,  0b00011_000000_00000_0000_000000000000, PbOp },
	{ "pcnd",  4,  0b000110_00000_00000_0001_000000000000, PcOp },
	// pb1 "macros"
	{ "peq",   3,  0b00011_000000_00000_0000_000000000000, Pred },
	{ "pne",   3,  0b00011_000010_00000_0000_000000000000, Pred },
	{ "pge",   3,  0b00011_000100_00000_0000_000000000000, Pred },
	{ "plt",   3,  0b00011_000110_00000_0000_000000000000, Pred },
	{ "pgt",   3,  0b00011_001000_00000_0000_000000000000, Pred },
	{ "ple",   3,  0b00011_001010_00000_0000_000000000000, Pred },
	{ "phs",   3,  0b00011_001100_00000_0000_000000000000, Pred },
	{ "plo",   3,  0b00011_001101_00000_0000_000000000000, Pred },
	{ "phi",   3,  0b00011_001110_00000_0000_000000000000, Pred },
	{ "pls",   3,  0b00011_001111_00000_0000_000000000000, Pred },
	{ "psin",  4,  0b00011_011000_00000_0000_000000000000, Pred },
	{ "pfin",  4,  0b00011_011001_00000_0000_000000000000, Pred },
	{ "pcin",  4,  0b00011_011010_00000_0000_000000000000, Pred },
	{ "prin",  4,  0b00011_011011_00000_0000_000000000000, Pred },
	// pcnd "macros"
	{ "peq0",  4,  0b000110_00000_00000_0001_000000000000, Pred },
	{ "pne0",  4,  0b000110_00001_00000_0001_000000000000, Pred },
	{ "pge0",  4,  0b000110_00010_00000_0001_000000000000, Pred },
	{ "plt0",  4,  0b000110_00011_00000_0001_000000000000, Pred },
	{ "pgt0",  4,  0b000110_00100_00000_0001_000000000000, Pred },
	{ "ple0",  4,  0b000110_00101_00000_0001_000000000000, Pred },
	// the next two are HR variants
	{ "jmp",   3,  0b001101_00000_00000_01000_000000_00000, BiOp },
	{ "calli", 5,  0b001101_00000_00000_01100_000000_00000, BiOp },
	{ "calx",  4,  0b000000_00000_00000_00000_100011_00000, MemOp},
	{ "cala",  4,  0b000000_00000_00000_00000_100111_00000, MemOp},

	{ "jttb",  4,  0b011011_00000_00000_00000_000000_00000, JtOp },
	{ "jtth",  4,  0b011011_00001_00000_00000_000000_00000, JtOp },
	{ "jttw",  4,  0b011011_00010_00000_00000_000000_00000, JtOp },
	{ "jttd",  4,  0b011011_00011_00000_00000_000000_00000, JtOp },

	{ "carry", 5,  0b111100_000000_0001_0000000000000000, CarryOp },
	{ "vec",   3,  0b111101_000000_00000000000000000000, VecOp },
	{ "ldm",   3,  0b001001_00000_00000_00000_010011_00000, LdmOp },
	{ "stm",   3,  0b001001_00000_00000_00000_010100_00000, LdmOp },
	{ "mm",    2,  0b001001_00000_00000_00000_110110_00000, MmOp },
	{ "ms",    2,  0b001001_00000_00000_00000_110111_00000, MmOp },
	{ "enter", 5,  0b101100_00000_00000_0000000000000000, EnterOp },
	{ "exit",  4,  0b100111_00000_00000_0000000000000000, EnterOp },

	{ "cmov",  4,  0b001100_00000_00000_001001_00000_00000, Int3Op },
	{ "mux",   3,  0b001100_00000_00000_000001_00000_00000, Int3Op },
	{ "ins",   3,  0b001100_00000_00000_000010_00000_00000, Int3Op },

	{ "loop1", 5,  0b010101_00000_00000_000001_00000_00000, LoopOp },
	{ "loop2", 5,  0b010101_00000_00000_000010_00000_00000, LoopOp },
	{ "loop3", 5,  0b010101_00000_00000_000011_00000_00000, LoopOp },


	{ "abs",   3,  0b001101_00000_00000_00000_000101_00000, Int1Op },
	{ "mvv",   3,  0b001101_00000_00000_00010_000101_00000, Int1Op },//FIXME
	{ "fabs",  4,  0b001101_00000_00000_00000_000101_00001, Int1Op },
	{ "fabsf", 5,  0b001101_00000_00000_00010_000101_00001, Int1Op },
	{ "expon", 5,  0b001101_00000_00000_00000_000110_00000, Int1Op },
	{ "exponf",6,  0b001101_00000_00000_00010_000110_00000, Int1Op },
	{ "fract", 5,  0b001101_00000_00000_00000_000111_00000, Int1Op },
	{ "fractf",6,  0b001101_00000_00000_00010_000111_00000, Int1Op },
	{ "pop",   3,  0b001101_00000_00000_00000_001000_00000, Int1Op },
	{ "clz",   3,  0b001101_00000_00000_00000_001001_00000, Int1Op },
	{ "ctz",   3,  0b001101_00000_00000_00010_001001_00000, Int1Op },
	{ "clo",   3,  0b001101_00000_00000_01000_001001_00000, Int1Op },
	{ "cto",   3,  0b001101_00000_00000_01010_001001_00000, Int1Op },
	// experimental
	{ "hrr",   3,  0b001101_00000_00000_00100_000000_00000, HrOp },
	{ "hrw",   3,  0b001101_00000_00000_01000_000000_00000, HrOp },
	{ "hrx",   3,  0b001101_00000_00000_01100_000000_00000, HrOp },

	// 64-bit floating point
	{ "fadd",  4,  0b000000_00000_00000_00000_110001_00000, IntOp },
	{ "fsub",  4,  0b000000_00000_00000_00100_110001_00000, IntOp },
	{ "fmul",  4,  0b000000_00000_00000_00000_110010_00000, IntOp },
	{ "fdiv",  4,  0b000000_00000_00000_00000_110011_00000, IntOp },
	{ "fcmp",  4,  0b000000_00000_00000_00000_110100_00000, IntOp },
	{ "fmax",  4,  0b000000_00000_00000_00000_110110_00000, IntOp },
	{ "fmin",  4,  0b000000_00000_00000_00000_110111_00000, IntOp },
	{ "csgn",  4,  0b000000_00000_00000_00000_111001_00000, IntOp },
	{ "eadd",  4,  0b000000_00000_00000_00000_111010_00000, IntOp },
	{ "fmac",  4,  0b001100_00000_00000_000000_00000_00000, FmacOp },
	// 32-bit floating point
	{ "faddf", 5,  0b000000_00000_00000_00010_110001_00000, IntOp },
	{ "fsubf", 5,  0b000000_00000_00000_00110_110001_00000, IntOp },
	{ "fmulf", 5,  0b000000_00000_00000_00010_110010_00000, IntOp },
	{ "fdivf", 5,  0b000000_00000_00000_00010_110011_00000, IntOp },
	{ "fcmpf", 5,  0b110100_00000_00000_00010_110100_00000, IntOp },
	{ "fmaxf", 5,  0b000000_00000_00000_00010_110110_00000, IntOp },
	{ "fminf", 5,  0b000000_00000_00000_00010_110111_00000, IntOp },
	{ "csgnf", 5,  0b000000_00000_00000_00010_111001_00000, IntOp },
	{ "eaddf", 5,  0b000000_00000_00000_00010_111010_00000, IntOp },
	{ "fmacf", 5,  0b001100_00000_00000_000100_00000_00000, FmacOp },
	// 64-bit floating point branch conditions
	{ "bdeq",  4,  0b011010_01000_00000_0000000000000000, BcmOp },
	{ "bdne",  4,  0b011010_01001_00000_0000000000000000, BcmOp },
	{ "bdge",  4,  0b011010_01010_00000_0000000000000000, BcmOp },
	{ "bdlt",  4,  0b011010_01011_00000_0000000000000000, BcmOp },
	{ "bdgt",  4,  0b011010_01100_00000_0000000000000000, BcmOp },
	{ "bdle",  4,  0b011010_01101_00000_0000000000000000, BcmOp },
	{ "bdor",  4,  0b011010_01110_00000_0000000000000000, BcmOp },
	{ "bdun",  4,  0b011010_01111_00000_0000000000000000, BcmOp },
	// 32-bit floating point branch conditions
	{ "bfeq",  4,  0b011010_10000_00000_0000000000000000, BcmOp },
	{ "bfne",  4,  0b011010_10001_00000_0000000000000000, BcmOp },
	{ "bfge",  4,  0b011010_10010_00000_0000000000000000, BcmOp },
	{ "bflt",  4,  0b011010_10011_00000_0000000000000000, BcmOp },
	{ "bfgt",  4,  0b011010_10100_00000_0000000000000000, BcmOp },
	{ "bfle",  4,  0b011010_10101_00000_0000000000000000, BcmOp },
	{ "bfor",  4,  0b011010_10110_00000_0000000000000000, BcmOp },
	{ "bfun",  4,  0b011010_10111_00000_0000000000000000, BcmOp },
	// floating point compare bits
	{ "bneq",  4,  0b01100_000001_00000_0000000000000000, BbmOp },
	{ "bnne",  4,  0b01100_000011_00000_0000000000000000, BbmOp },
	{ "bnge",  4,  0b01100_000101_00000_0000000000000000, BbmOp },
	{ "bnlt",  4,  0b01100_000111_00000_0000000000000000, BbmOp },
	{ "bngt",  4,  0b01100_001001_00000_0000000000000000, BbmOp },
	{ "bnle",  4,  0b01100_001011_00000_0000000000000000, BbmOp },
	{ "bor",   3,  0b01100_010000_00000_0000000000000000, BbmOp },
	{ "bnor",  4,  0b01100_010001_00000_0000000000000000, BbmOp },
	{ "btor",  4,  0b01100_010010_00000_0000000000000000, BbmOp },
	{ "bntor", 5,  0b01100_010011_00000_0000000000000000, BbmOp },
	{ "bsnan", 5,  0b01100_100000_00000_0000000000000000, BbmOp },
	{ "bqnan", 5,  0b01100_100001_00000_0000000000000000, BbmOp },
	// 64-bit floating point predicates
	{ "pdeq",  4,  0b000110_01000_00000_0001_000000000000, Pred },
	{ "pdne",  4,  0b000110_01001_00000_0001_000000000000, Pred },
	{ "pdge",  4,  0b000110_01010_00000_0001_000000000000, Pred },
	{ "pdlt",  4,  0b000110_01011_00000_0001_000000000000, Pred },
	{ "pdgt",  4,  0b000110_01100_00000_0001_000000000000, Pred },
	{ "pdle",  4,  0b000110_01101_00000_0001_000000000000, Pred },
	{ "pdor",  4,  0b000110_01110_00000_0001_000000000000, Pred },
	{ "pdun",  4,  0b000110_01111_00000_0001_000000000000, Pred },
	// 32-bit floating point predicates
	{ "pfeq",  4,  0b000110_10000_00000_0001_000000000000, Pred },
	{ "pfne",  4,  0b000110_10001_00000_0001_000000000000, Pred },
	{ "pfge",  4,  0b000110_10010_00000_0001_000000000000, Pred },
	{ "pflt",  4,  0b000110_10011_00000_0001_000000000000, Pred },
	{ "pfgt",  4,  0b000110_10100_00000_0001_000000000000, Pred },
	{ "pfle",  4,  0b000110_10101_00000_0001_000000000000, Pred },
	{ "pfor",  4,  0b000110_10110_00000_0001_000000000000, Pred },
	{ "pfun",  4,  0b000110_10111_00000_0001_000000000000, Pred },
	// pb1 floating point "macros"
	{ "pneq",  4,  0b00011_000001_00000_0000_000000000000, Pred },
	{ "pnne",  4,  0b00011_000011_00000_0000000000000000, BbmOp },
	{ "pnge",  4,  0b00011_000101_00000_0000000000000000, BbmOp },
	{ "pnlt",  4,  0b00011_000111_00000_0000000000000000, BbmOp },
	{ "pngt",  4,  0b00011_001001_00000_0000000000000000, BbmOp },
	{ "pnle",  4,  0b00011_001011_00000_0000000000000000, BbmOp },
	{ "por",   3,  0b00011_010000_00000_0000000000000000, BbmOp },
	{ "pnor",  4,  0b00011_010001_00000_0000000000000000, BbmOp },
	{ "ptor",  4,  0b00011_010010_00000_0000000000000000, BbmOp },
	{ "pntor", 5,  0b00011_010011_00000_0000000000000000, BbmOp },
	{ "psnan", 5,  0b00011_100000_00000_0000000000000000, BbmOp },
	{ "pqnan", 5,  0b00011_100001_00000_0000000000000000, BbmOp },
	// conversions
	{ "cvtus",   5, 0b000000_00000_00000_00000_000001_00000, IntOp },
	{ "cvtsu",   5, 0b000000_00000_00000_00010_000001_00000, IntOp },
	{ "cvtsd",   5, 0b000000_00000_00000_00000_000010_00000, IntOp },
	{ "cvtsf",   5, 0b000000_00000_00000_00010_000010_00000, IntOp },
	{ "cvtud",   5, 0b000000_00000_00000_00000_000011_00000, IntOp },
	{ "cvtuf",   5, 0b000000_00000_00000_00010_000011_00000, IntOp },
	{ "cvtdu",   5, 0b000000_00000_00000_00000_010001_00000, IntOp },
	{ "cvtds",   5, 0b000000_00000_00000_00010_010001_00000, IntOp },
	{ "cvtfu",   5, 0b000000_00000_00000_00000_010010_00000, IntOp },
	{ "cvtfs",   5, 0b000000_00000_00000_00010_010010_00000, IntOp },
	{ "cvtdf",   5, 0b000000_00000_00000_00000_010011_00000, IntOp },
	{ "cvtfd",   5, 0b000000_00000_00000_00010_010011_00000, IntOp },
	// round
	{ "rnd",     3, 0b000000_00000_00000_00000_010100_00000, IntOp },
	{ "rndf",    4, 0b000000_00000_00000_00010_010100_00000, IntOp },
	// transcendentals
	{ "fln2",    4, 0b001101_00000_00000_00000_011000_00000, Xop5 },
	{ "fln",     3, 0b001101_00000_00000_00000_011000_00001, Xop5 },
	{ "flog",    4, 0b001101_00000_00000_00000_011000_00010, Xop5 },
	{ "fexp2",   5, 0b001101_00000_00000_00000_011000_00100, Xop5 },
	{ "fexp",    4, 0b001101_00000_00000_00000_011000_00101, Xop5 },
	{ "fexp10",  6, 0b001101_00000_00000_00000_011000_00110, Xop5 },
	{ "frcp",    4, 0b001101_00000_00000_00000_011000_01000, Xop5 },
	{ "frsqrt",  6, 0b001101_00000_00000_00000_011000_01100, Xop5 },
	{ "fsqrt",   5, 0b001101_00000_00000_00000_011000_01101, Xop5 },
	{ "fln2p1",  6, 0b001101_00000_00000_00000_011000_10000, Xop5 },
	{ "flnp1",   5, 0b001101_00000_00000_00000_011000_10001, Xop5 },
	{ "flogp1",  6, 0b001101_00000_00000_00000_011000_10010, Xop5 },
	{ "fexp2m1", 7, 0b001101_00000_00000_00000_011000_10100, Xop5 },
	{ "fexpm1",  6, 0b001101_00000_00000_00000_011000_10101, Xop5 },
	{ "fexp10m1",8, 0b001101_00000_00000_00000_011000_10110, Xop5 },
	{ "fsin",    4, 0b001101_00000_00000_00000_011000_11000, Xop5 },
	{ "fcos",    4, 0b001101_00000_00000_00000_011000_11001, Xop5 },
	{ "ftan",    4, 0b001101_00000_00000_00000_011000_11010, Xop5 },
	{ "fasin",   5, 0b001101_00000_00000_00000_011000_11100, Xop5 },
	{ "facos",   5, 0b001101_00000_00000_00000_011000_11101, Xop5 },
	{ "faton",   6, 0b001101_00000_00000_00000_011000_11110, Xop5 },
	// locking loads/stores
	{ "ldubl",  5,  0b100000_00000_00000_00010_000000_00000, MemOp },
	{ "lduhl",  5,  0b100001_00000_00000_00010_000001_00000, MemOp },
	{ "lduwl",  5,  0b100010_00000_00000_00010_000010_00000, MemOp },
	{ "lddl",   4,  0b100011_00000_00000_00010_000011_00000, MemOp },
	{ "ldsbl",  5,  0b100100_00000_00000_00010_000100_00000, MemOp },
	{ "ldshl",  5,  0b100101_00000_00000_00010_000101_00000, MemOp },
	{ "ldswl",  5,  0b100110_00000_00000_00010_000110_00000, MemOp },
	{ "lal",    3,  0b000000_00000_00000_00010_000111_00000, MemOp },
	{ "stbl",   4,  0b101000_00000_00000_00010_001000_00000, MemOp },
	{ "sthl",   4,  0b101001_00000_00000_00010_001001_00000, MemOp },
	{ "stwl",   4,  0b101010_00000_00000_00010_001010_00000, MemOp },
	{ "stdl",   4,  0b101011_00000_00000_00010_001011_00000, MemOp },
	// exotic branch on conditons
	{ "bin",   3,  0b011010_11000_00000_0000000000000000, BcmOp },
	{ "pin",   3,  0b000110_11000_00000_0000000000000000, Pred },
	{ "svc",   3,  0b011010_11101_00000_0000000000000000, SvcOp },
	{ "svr",   3,  0b011010_11110_00000_0000000000000000, SvcOp },
    };

    proc Instruction(s: @[]_byte, n: _uint)
    {   var t: @[]_byte;
	var op: _uint;

	t = SkipWS(s[n:0]);
	op = 0;
	while op < Insts?len &&
	      (Insts[op].len != n || Insts[op].name[0:n] != s[0:n]) do
	    op += 1;
	if op >= Insts?len then
	{   Syntax2n("illegal instruction ", s, n);
	    return;
	}
	Insts[op].parse@(t, Insts[op].opt);
    }

import pseudo;

    proc Parse(file: @[]_byte, listing: boolean)
    {
	var line, opc, arg, nxt: @[]_byte;
	var j, n: _uint;

	if file != 0 then
	{   if !bufin.Open(file) then
	    {	// error can't open file
		return;
	    }
	    filename = file;
	}
	else
	{   bufin.Init(0);	// read stdin
	    filename = "(STDIN)";
	}

	lineno = 0;
	loop
	{   line, n = bufin.GetLine();
	  exit n == 0;
	    lineno += 1;
	    opc = SkipWS(line[0:]);
	    loop
	    {   arg, j = lex.Label(opc[0:]);
	      exit j == 0;			// no symbol
		nxt = SkipWS(arg[0:]);
	      exit nxt[0] != ':';		// not a label
		symbol.Label(opc, j);
		opc = SkipWS(nxt[1:]);
	    }
	    if j > 0 then
	    {   if opc[0] == '.' then
		    PseudoOp(opc[1:], j-1);
	        else
	  	    Instruction(opc[0:], j);
	    }
	    if listing then
	    {
		fdo.strn(line, n);
	    }
    	}
    }
}

